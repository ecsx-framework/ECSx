# Web Frontend with LiveView

Since we're using Phoenix, we can take advantage of the many features it brings for building a web interface.

## Player Auth

When it comes to player auth, there are two sides to the coin:  authentication (AuthN) and authorization (AuthZ).  The former refers to verifying the identity of a player (and will be our primary focus, for now), while the latter refers to checking whether a user has permission to take a restricted action.

Phoenix comes with an [AuthN generator](https://hexdocs.pm/phoenix/Mix.Tasks.Phx.Gen.Auth.html) built-in, which should be more than enough for our needs:

    $ mix phx.gen.auth Players Player players --binary-id
    $ mix deps.get
    $ mix ecto.migrate

This will expect players to register an email and password, which will be used to log in.  A unique ID will also be created for each player upon registration, allowing us to begin thinking of players as entities.  However, we can't just take the player input and start creating components with it - only systems can create components.  Instead, we'll use a special component type provided for this purpose: `ECSx.ClientEvents`.

## Adding ECSx.ClientEvents

First head into `application.ex` and add it to your supervision tree:

```elixir
def start(_type, _args) do
  children = [
    ...
    # You can add this anywhere in the list, as long as it's before `MyAppWeb.Endpoint`.
    ECSx.ClientEvents,
    ...
    MyAppWeb.Endpoint
  ]

  opts = [strategy: :one_for_one, name: MyApp.Supervisor]
  Supervisor.start_link(children, opts)
end
```

## Client Input via LiveView

Then we'll create `/lib/my_app_web/game_live.ex` and put it to use:

```elixir
defmodule MyAppWeb.GameLive do
  use MyAppWeb, :live_view
  ...
  def mount(_params, %{"player_token" => token} = _session, socket) do
    # This context function was generated by phx.gen.auth
    player = MyApp.Players.get_player_by_session_token(token)
    
    # We must spawn the ship before processing any other input
    ECSx.ClientEvents.add(player.id, :spawn_ship)

    # We want to keep up-to-date on our ship's location
    :timer.send_interval(50, :refresh_current_location)

    # Keeping a set of currently held keys will allow us to prevent duplicate keydown events
    keys = MapSet.new()

    {:ok, assign(socket, player: player, keys: keys, current_location: nil)}
  end

  def handle_event("keydown", %{"key" => key}, socket) do
    if MapSet.member?(socket.assigns.keys, key) do
      # Already holding this key - do nothing
      {:noreply, socket}
    else
      ECSx.ClientEvents.add(socket.assigns.player.id, keydown(key))
      {:noreply, assign(socket, keys: MapSet.put(socket.assigns.keys, key))}
    end
  end

  def handle_event("keyup", %{"key" => key}, socket) do
    # We don't have to worry about duplicate keyup events
    ECSx.ClientEvents.add(socket.assigns.player.id, keyup(key))
    {:noreply, assign(socket, keys: MapSet.delete(socket.assigns.keys, key))}
  end

  defp keydown(key) when key in ~w(w W ArrowUp), do: {:move, :north}
  defp keydown(key) when key in ~w(a A ArrowLeft), do: {:move, :west}
  defp keydown(key) when key in ~w(s S ArrowDown), do: {:move, :south}
  defp keydown(key) when key in ~w(d D ArrowRight), do: {:move, :east}

  defp keyup(key) when key in ~w(w W ArrowUp), do: {:stop_move, :north}
  defp keyup(key) when key in ~w(a A ArrowLeft), do: {:stop_move, :west}
  defp keyup(key) when key in ~w(s S ArrowDown), do: {:stop_move, :south}
  defp keyup(key) when key in ~w(d D ArrowRight), do: {:stop_move, :east}

  def handle_info(:refresh_current_location, socket) do
    player_entity = socket.assigns.player.id
    x = XPosition.get_one(player_entity)
    y = YPosition.get_one(player_entity)

    {:noreply, assign(socket, current_location: {x, y})}
  end

  def render(assigns) do
    ~H"""
    <div id="game" phx-window-keydown="keydown" phx-window-keyup="keyup">
      <p>Player ID: <%= @player.id %></p>
      <p>Player Coords: <%= inspect(@current_location) %></p>
    </div>
    """
  end
end
```

## Handling Client Events

Finally, spin up a new system for handling the events:

    $ mix ecsx.gen.system ClientEventHandler

```elixir
defmodule MyApp.Systems.ClientEventHandler do
  ...
  def run do
    client_events = ECSx.ClientEvents.get_and_clear()

    Enum.each(client_events, &process_one/1)
  end

  defp process_one(player, :spawn_ship) do
    ArmorRating.add(player, 2)
    AttackDamage.add(player, 6)
    AttackRange.add(player, 15)
    AttackSpeed.add(player, 1.2)
    HullPoints.add(player, 75)
    SeekingTarget.add(player)
    XPosition.add(player, Enum.random(1..100))
    YPosition.add(player, Enum.random(1..100))
  end

  defp process_one({player, {:move, :north}}), do: YVelocity.add(player, 1)
  defp process_one({player, {:move, :south}}), do: YVelocity.add(player, -1)
  defp process_one({player, {:move, :east}}), do: XVelocity.add(player, 1)
  defp process_one({player, {:move, :west}}), do: XVelocity.add(player, -1)

  defp process_one({player, {:stop_move, direction}}) when direction in [:north, :south],
    do: YVelocity.remove(player)

  defp process_one({player, {:stop_move, direction}}) when direction in [:east, :west],
    do: XVelocity.remove(player)
end
```

Notice how the LiveView client can write to `ECSx.ClientEvents`, while the system handles and also clears the events.  This ensures that we don't process the same event twice, nor will any events get "lost" and not processed.

## Creating a Phoenix Route

Head into `router.ex` and look for the new scope which uses `:require_authenticated_player`.  We're going to add a new route for our game interface:

```elixir
scope "/", MyAppWeb do
  pipe_through [:browser, :require_authenticated_player]

  live "/game", MyAppWeb.GameLive
  ...
end
```

Now we can run

    $ iex -S mix phx.server

and go to `localhost:4000/game` to test the input.  Once you are logged in, wait for the player coords to display (this will be the indicator that your ship has spawned), and try moving around with `WASD` or arrow keys!

## Coming Soon

Build a display in our LiveView render