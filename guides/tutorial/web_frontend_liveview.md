# Web Frontend with LiveView

Since we're using Phoenix, we can take advantage of the many features it brings for building a web interface.

## Player Auth

When it comes to player auth, there are two sides to the coin:  authentication (AuthN) and authorization (AuthZ).  The former refers to verifying the identity of a player (and will be our primary focus, for now), while the latter refers to checking whether a user has permission to take a restricted action.

Phoenix comes with an [AuthN generator](https://hexdocs.pm/phoenix/Mix.Tasks.Phx.Gen.Auth.html) built-in, which should be more than enough for our needs:

    $ mix phx.gen.auth Players Player players --binary-id
    $ mix deps.get
    $ mix ecto.migrate

This will expect players to register an email and password, which will be used to log in.  A unique ID will also be created for each player upon registration, allowing us to begin thinking of players as entities.  However, we can't just take the player input and start creating components with it - only systems can create components.  Instead, we'll use a special component type provided for this purpose: `ECSx.ClientEvents`.

## Client Input via LiveView

First consider the goals for our frontend:

  * Authenticate the player and hold player ID
  * Spawn the player's ship upon connection (writes components)
  * Hold the coordinates for the player's ship
  * Hold the coordinates for enemy ships
  * Validate user input to move the ship (writes components)

When we need to write components, `ECSx.ClientEvents` will be our line of communication from the frontend to the backend.  

Let's create `/lib/my_app_web/game_live.ex` and put it to use:

```elixir
defmodule MyAppWeb.GameLive do
  use MyAppWeb, :live_view
  ...
  def mount(_params, %{"player_token" => token} = _session, socket) do
    # This context function was generated by phx.gen.auth
    player = MyApp.Players.get_player_by_session_token(token)
    
    # We must spawn the ship before processing any other input
    ECSx.ClientEvents.add(player.id, :spawn_ship)

    socket =
      socket
      |> assign(player_entity: player.id)
      # Keeping a set of currently held keys will allow us to prevent duplicate keydown events
      |> assign(keys: MapSet.new())
      # We don't know where the ship will spawn, yet
      |> assign(x_coord: nil, y_coord: nil, current_hp: nil)

    :timer.send_interval(50, :load_player_info)

    {:ok, socket}
  end

  def handle_info(:load_player_info, socket) do
    # This will run every 50ms to keep the client assigns updated
    x = XPosition.get_one(socket.assigns.player_entity)
    y = YPosition.get_one(socket.assigns.player_entity)
    hp = HullPoints.get_one(socket.assigns.player_entity)

    {:noreply, assign(socket, x_coord: x, y_coord: y, current_hp: hp)}
  end

  def handle_event("keydown", %{"key" => key}, socket) do
    if MapSet.member?(socket.assigns.keys, key) do
      # Already holding this key - do nothing
      {:noreply, socket}
    else
      # We only want to add a client event if the key is defined by the `keydown/1` helper below
      maybe_add_client_event(socket.assigns.player_entity, key, &keydown/1)
      {:noreply, assign(socket, keys: MapSet.put(socket.assigns.keys, key))}
    end
  end

  def handle_event("keyup", %{"key" => key}, socket) do
    # We don't have to worry about duplicate keyup events
    # But once again, we will only add client events for keys that actually do something
    maybe_add_client_event(socket.assigns.player_entity, key, &keyup/1)
    {:noreply, assign(socket, keys: MapSet.delete(socket.assigns.keys, key))}
  end

  defp maybe_add_client_event(player_entity, key, fun) do
    case fun.(key) do
      :noop -> :ok
      event -> ECSx.ClientEvents.add(player_entity, event)
    end
  end

  defp keydown(key) when key in ~w(w W ArrowUp), do: {:move, :north}
  defp keydown(key) when key in ~w(a A ArrowLeft), do: {:move, :west}
  defp keydown(key) when key in ~w(s S ArrowDown), do: {:move, :south}
  defp keydown(key) when key in ~w(d D ArrowRight), do: {:move, :east}
  defp keydown(_key), do: :noop

  defp keyup(key) when key in ~w(w W ArrowUp), do: {:stop_move, :north}
  defp keyup(key) when key in ~w(a A ArrowLeft), do: {:stop_move, :west}
  defp keyup(key) when key in ~w(s S ArrowDown), do: {:stop_move, :south}
  defp keyup(key) when key in ~w(d D ArrowRight), do: {:stop_move, :east}
  defp keyup(_key), do: :noop

  def render(assigns) do
    ~H"""
    <div id="game" phx-window-keydown="keydown" phx-window-keyup="keyup">
      <p>Player ID: <%= @player_entity %></p>
      <p>Player Coords: <%= inspect({@x_coord, @y_coord}) %></p>
      <p>Hull Points: <%= @current_hp %></p>
    </div>
    """
  end
end
```

## Handling Client Events

Finally, spin up a new system for handling the events:

    $ mix ecsx.gen.system ClientEventHandler

```elixir
defmodule MyApp.Systems.ClientEventHandler do
  ...
  def run do
    client_events = ECSx.ClientEvents.get_and_clear()

    Enum.each(client_events, &process_one/1)
  end

  defp process_one(player, :spawn_ship) do
    # We'll give player ships better stats than the enemy ships
    # (otherwise the game would be very short!)
    ArmorRating.add(player, 2)
    AttackDamage.add(player, 6)
    AttackRange.add(player, 15)
    AttackSpeed.add(player, 1.2)
    HullPoints.add(player, 75)
    SeekingTarget.add(player)
    XPosition.add(player, Enum.random(1..100))
    YPosition.add(player, Enum.random(1..100))
  end

  # Note Y movement will use screen position (increasing Y goes south)
  defp process_one({player, {:move, :north}}), do: YVelocity.add(player, -1)
  defp process_one({player, {:move, :south}}), do: YVelocity.add(player, 1)
  defp process_one({player, {:move, :east}}), do: XVelocity.add(player, 1)
  defp process_one({player, {:move, :west}}), do: XVelocity.add(player, -1)

  defp process_one({player, {:stop_move, :north}}), do: YVelocity.remove_one(player, -1)
  defp process_one({player, {:stop_move, :south}}), do: YVelocity.remove_one(player, 1)
  defp process_one({player, {:stop_move, :east}}), do: XVelocity.remove_one(player, 1)
  defp process_one({player, {:stop_move, :west}}), do: XVelocity.remove_one(player, -1)
end
```

Notice how the LiveView client can write to `ECSx.ClientEvents`, while the system handles and also clears the events.  This ensures that we don't process the same event twice, nor will any events get "lost" and not processed.

## Creating a Phoenix Route

Head into `router.ex` and look for the new scope which uses `:require_authenticated_player`.  We're going to add a new route for our game interface:

```elixir
scope "/", MyAppWeb do
  pipe_through [:browser, :require_authenticated_player]

  live "/game", MyAppWeb.GameLive
  ...
end
```

Now we can run

    $ iex -S mix phx.server

and go to `localhost:4000/game` to test the input.  Once you are logged in, wait for the player coords to display (this will be the indicator that your ship has spawned), and try moving around with `WASD` or arrow keys!

## Loading Screen

You might notice that while the ship is spawning, the Player Coords and Hull Points don't display properly - this isn't a major issue now, but once our coordinates are being used by a more sophisticated display, this will not be acceptable.  What we need is a loading screen to show the user until the necessary data is properly loaded.

First, let's create a new `ECSx.Tag` to mark when a player's ship has finished spawning:

    $ mix ecsx.gen.tag PlayerSpawned

Then we'll add this tag at the end of the `:spawn_ship` client event

```elixir
defmodule MyApp.Systems.ClientEventHandler do
  ...
  defp process_one(player, :spawn_ship) do
    ...
    PlayerSpawned.add(player)
  end
  ...
end
```

Now we'll update our LiveView to use a new `@loading` assign which is initially set to `true`, then set to `false` after the ship is spawned and the data is loaded for the first time.

```elixir
defmodule MyAppWeb.GameLive do
  ...
  def mount(_params, %{"player_token" => token} = _session, socket) do
    player = MyApp.Players.get_player_by_session_token(token)
    ECSx.ClientEvents.add(player.id, :spawn_ship)

    socket =
      socket
      |> assign(player_entity: player.id)
      |> assign(keys: MapSet.new())
      # This gets its own helper in case we need to return to this state again later
      |> assign_loading_state()

    # The first load will now have additional responsibilities
    send(self(), :first_load)

    {:ok, socket}
  end

  defp assign_loading_state(socket) do
    assign(socket,
      x_coord: nil,
      y_coord: nil,
      current_hp: nil,
      # This new assign will control whether the loading screen is shown
      loading: true
    )
  end

  def handle_info(:first_load, socket) do
    # Don't start fetching components until after spawn is complete!
    :ok = wait_for_spawn(socket.assigns.player_entity)

    socket =
      socket
      |> assign_player_ship()
      |> assign(loading: false)

    # We want to keep up-to-date on this info
    :timer.send_interval(50, :refresh)

    {:noreply, socket}
  end

  def handle_info(:refresh, socket) do
    {:noreply, assign_player_ship(socket)}
  end

  defp wait_for_spawn(player_entity) do
    if PlayerSpawned.exists?(player_entity) do
      :ok
    else
      Process.sleep(10)
      wait_for_spawn(player_entity)
    end
  end

  # Our previous :load_player_info handler becomes a shared helper for the new handlers
  defp assign_player_ship(socket) do
    x = XPosition.get_one(socket.assigns.player_entity)
    y = YPosition.get_one(socket.assigns.player_entity)
    hp = HullPoints.get_one(socket.assigns.player_entity)

    assign(socket, x_coord: x, y_coord: y, current_hp: hp)
  end

  ...

  def render(assigns) do
    ~H"""
    <div id="game" phx-window-keydown="keydown" phx-window-keyup="keyup">
      <%= if @loading do %>
        <p>Loading...</p>
      <% else %>
        <p>Player ID: <%= @player_entity %></p>
        <p>Player Coords: <%= inspect({@x_coord, @y_coord}) %></p>
        <p>Hull Points: <%= @current_hp %></p>
      <% end %>
    </div>
    """
  end
end
```

## Player GUI using SVG

One of the simplest ways to build a display for web is with SVG.  Each entity can be represented by a single SVG element, which only requires its coordinates.  Then a `viewBox` can zoom the player's display in to show just the local area around their ship.

```elixir
defmodule MyAppWeb.GameLive do
  ...
  def render(assigns) do
    ~H"""
    <div id="game" phx-window-keydown="keydown" phx-window-keyup="keyup">
      <svg
        viewBox={"#{@x_offset} #{@y_offset} #{@screen_width} #{@screen_height}"}
        preserveAspectRatio="xMinYMin slice"
      >
        <rect width={@game_world_size} height={@game_world_size} fill="#72eff8" />

        <%= if @loading do %>
          <text x={div(@screen_width, 2)} y={div(@screen_height, 2)} style="font: 1px serif">
            Loading...
          </text>
        <% else %>
          <image
            x={@x_coord}
            y={@y_coord}
            width="1"
            height="1"
            href={Routes.static_path(@socket, "/images/player_ship.svg")}
          />
          <%= for {_entity, x, y} <- @other_ships do %>
            <image
              x={x}
              y={y}
              width="1"
              height="1"
              href={Routes.static_path(@socket, "/images/other_ship.svg")}
            />
          <% end %>
          <text x={@x_offset} y={@y_offset + 1} style="font: 1px serif">
            Hull Points: <%= @current_hp %>
          </text>
        <% end %>
      </svg>
    </div>
    """
  end
end
```

We've added a lot here, so let's go line-by-line:

We're filling the screen with an [`svg viewBox`](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/viewBox), which takes four arguments.  The first two - x and y offsets - tell the viewBox what area of the map to focus on, while the latter two - screen width and height - tell it how much to zoom in.  To get the offsets, we'll need to calculate the coordinate pair which should be at the very top-left of the player's view.  This will need to be updated every time the player moves.  The screen width and height (measured by game coordinates) will be assigned on mount and won't change.  The `preserveAspectRatio` has two parts: `xMinYMin` means we define the offset by the top-left coordinate, and `slice` means we're only expecting to show a "slice" of the map in our viewBox, not the whole thing.

Our first element will be a simple `rect` (rectangle) with a light-blue fill to cover the entire world map.  This will be the "background" - representing the ocean.  The game world will consistently be 100x100, so we can assign a `game_world_size` of 100 for this purpose.

The loading screen will still use the same viewBox and background, but with only one other element - `text` to display a loading message in the center of the screen.  One curiosity regarding the font size:  we use `1px`, but you'll see later that the text is actually quite large.  This is because the viewBox considers each game "tile" to be 1 pixel, and automatically scales these pixels up to a larger size based on the screen width and height compared to the size of the browser window.  So when we say `font: 1px` it means the text will be as tall as one game tile.

Once the game is finished loading, we'll display three things:  the player's ship, other ships, and the player's current HP.

For the player's ship, we'll make an `image` element, using the existing x and y coordinates, defining the size as one game tile, and pointing to the `player_ship.svg` source file.

For other ships, we'll need a new assign to hold that data - ID and coordinates, at minimum.  Then each one will get an `image` just like the player's ship, but with a different source file to set them apart visually.

Lastly, we'll put an HP display near the top-left corner.

Next is to update our LiveView with these new assigns:

```elixir
defmodule MyAppWeb.GameLive do
  ...
  def mount(_params, %{"player_token" => token} = _session, socket) do
    player = Ship.Players.get_player_by_session_token(token)
    ECSx.ClientEvents.add(player.id, :spawn_ship)

    socket =
      socket
      |> assign(player_entity: player.id)
      |> assign(keys: MapSet.new())
      # These will configure the scale of our display compared to the game world
      |> assign(game_world_size: 100, screen_height: 30, screen_width: 50)
      |> assign_loading_state()
    
    send(self(), :first_load)

    {:ok, socket}
  end

  defp assign_loading_state(socket) do
    assign(socket,
      x_coord: nil,
      y_coord: nil,
      current_hp: nil,
      other_ships: [],
      x_offset: 0,
      y_offset: 0,
      loading: true
    )
  end

  def handle_info(:first_load, socket) do
    :ok = wait_for_spawn(socket.assigns.player_entity)

    socket =
      socket
      |> assign_player_ship()
      |> assign_other_ships()
      |> assign_offsets()
      |> assign(loading: false)

    :timer.send_interval(50, :refresh)

    {:noreply, socket}
  end

  def handle_info(:refresh, socket) do
    socket =
      socket
      |> assign_player_ship()
      |> assign_other_ships()
      |> assign_offsets()

    {:noreply, socket}
  end
  ...
  defp assign_other_ships(socket) do
    other_ships =
      Enum.reject(all_ships(), fn {entity, _x, _y} -> entity == socket.assigns.player_entity end)

    assign(socket, other_ships: other_ships)
  end

  defp all_ships do
    xs = XPosition.get_all() |> Enum.sort()
    ys = YPosition.get_all() |> Enum.sort()

    Enum.zip_with(xs, ys, fn {entity, x}, {entity, y} -> {entity, x, y} end)
  end

  defp assign_offsets(socket) do
    # Note: the socket must already have updated player coordinates before assigning offsets!
    %{screen_width: screen_width, screen_height: screen_height} = socket.assigns
    %{x_coord: x, y_coord: y, game_world_size: game_world_size} = socket.assigns

    x_offset = calculate_offset(x, screen_width, game_world_size)
    y_offset = calculate_offset(y, screen_height, game_world_size)

    assign(socket, x_offset: x_offset, y_offset: y_offset)
  end

  defp calculate_offset(coord, screen_size, game_world_size) do
    case coord - div(screen_size, 2) do
      offset when offset < 0 -> 0
      offset when offset > game_world_size - screen_size -> game_world_size - screen_size
      offset -> offset
    end
  end
end
```

Lastly, we'll need the [player_ship.svg]([https://github.com/APB9785/ship/blob/master/priv/static/images/player_ship.svg) and [other_ship.svg](https://github.com/APB9785/ship/blob/master/priv/static/images/other_ship.svg) files.  Right-click on the links and save them to `priv/static/images/`, where they will be found by our `Routes.static_path/2` calls in the LiveView template.

Now running

    $ iex -S mix phx.server

and heading to `localhost:4000/game` should provide a usable game interface to move your ship around, ideally keeping it out of attack range of enemy ships, while remaining close enough for your own ship to attack (remember that we gave the player ship a longer attack range than the enemy ships).

## Coming Soon

Currently the most challenging part of the game is knowing when your ship is attacking, and when it is being attacked.  An upcoming guide will show an example of rendering projectile animations!